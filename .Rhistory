tabPanel("Gráfico 4: Intervalo promedio entre compras",
plotOutput("grafico4b"),
plotOutput("grafico4h")
),
tabPanel("Gráfico 5: Compras por día de la semana",
plotOutput("grafico5")
)
)
)
#Server
server<- function(input, output, session) {
#Gráfico 1
output$grafico1 <- renderPlot({
tickets_enc %>%
group_by(num_ticket, id_cliente_enc) %>%
summarise(ArticulosPorCompra = n(), .groups = "drop") %>%
ggplot(aes(x = ArticulosPorCompra)) +
geom_histogram(color = "lightblue4", fill = "lightblue", binwidth = 1) +
labs(title = "Cantidad de artículos que se llevan por compra",
y = "Cantidad de tickets",
x = "Artículos por ticket") +
theme_minimal()
})
#Gráfico 2
output$grafico2 <- renderPlot({
top_articulos <- tickets_enc %>%
group_by(cod_est) %>%
summarise(Cantidad = n(), .groups = "drop") %>%
arrange(desc(Cantidad)) %>%
head(10) %>%
left_join(maestroestr, by = "cod_est")
ggplot(top_articulos, aes(x = reorder(descripcion, Cantidad), y = Cantidad)) +
geom_col(fill = "lightblue", color = "lightblue4") +
labs(title = "Top 10 artículos más comprados",
x = "Artículo",
y = "Cantidad de veces comprado") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
#Gráfico 3b y 3h
output$grafico3b <- renderPlot({
duraciones <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
primera_compra = min(dia),
ultima_compra = max(dia),
duracion_dias = as.numeric(ultima_compra - primera_compra),
.groups = "drop"
)
ggplot(duraciones, aes(y = duracion_dias)) +
geom_boxplot(fill = "lightblue", color = "lightblue4") +
labs(title = "Distribución del tiempo de actividad de los clientes",
y = "Duración entre primera y última compra (días)") +
theme_minimal()
})
output$grafico3h <- renderPlot({
duraciones <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
primera_compra = min(dia),
ultima_compra = max(dia),
duracion_dias = as.numeric(ultima_compra - primera_compra),
.groups = "drop"
)
ggplot(duraciones, aes(x = duracion_dias)) +
geom_histogram(binwidth = 30, fill = "lightblue", color = "lightblue4") +
labs(title = "Tiempo de actividad de los clientes",
x = "Duración entre primera y última compra (días)",
y = "Número de clientes") +
theme_minimal()
})
#Gráfico 4b y 4h
output$grafico4b <- renderPlot({
intervalos <- tickets_enc %>%
arrange(id_cliente_enc, dia) %>%
group_by(id_cliente_enc) %>%
mutate(intervalo = as.numeric(difftime(dia, lag(dia), units = "days"))) %>%
filter(!is.na(intervalo)) %>%
summarise(media_intervalo = mean(intervalo), .groups = "drop")
ggplot(intervalos, aes(y = media_intervalo)) +
geom_boxplot(color = "lightblue4", fill = "lightblue") +
labs(title = "Distribución de la frecuencia de compra de los clientes",
y = "Días promedio entre compras") +
coord_cartesian(ylim = c(0, 10)) +
theme_minimal()
})
output$grafico4h <- renderPlot({
intervalos <- tickets_enc %>%
arrange(id_cliente_enc, dia) %>%
group_by(id_cliente_enc) %>%
mutate(intervalo = as.numeric(difftime(dia, lag(dia), units = "days"))) %>%
filter(!is.na(intervalo)) %>%
summarise(media_intervalo = mean(intervalo), .groups = "drop")
ggplot(intervalos, aes(x = media_intervalo)) +
geom_histogram(binwidth = 1, color = "lightblue4", fill = "lightblue") +
labs(title = "Media de días entre compras por cliente",
x = "Media de días entre compras",
y = "Cantidad de clientes") +
coord_cartesian(xlim = c(0, 8)) +
theme_minimal()
})
#Gráfico 5
output$grafico5 <- renderPlot({
tickets_enc %>%
mutate(DiaSemana = wday(dia)) %>%
group_by(DiaSemana) %>%
summarise(CantidadProductos = n(), .groups = "drop") %>%
mutate(DiaSemana = factor(DiaSemana, levels = 1:7, labels = c("Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"))) %>%
ggplot(aes(x = CantidadProductos, y = reorder(DiaSemana, CantidadProductos))) +
geom_col(fill = "lightblue", color = "lightblue4") +
labs(title = "Cantidad de productos comprados por día de la semana",
x = "Cantidad de Productos",
y = "Día de la Semana") +
theme_minimal()
})
}
#Ejecutar app
shinyApp(ui = ui, server = server)
#Definir la UI
ui<- fluidPage(
titlePanel("Análisis Exploratorio - Reto 4"),
tabsetPanel(
tabPanel("Gráfico 1: Artículos por compra",
plotOutput("grafico1")
),
tabPanel("Gráfico 2: Top artículos comprados",
plotOutput("grafico2")
),
tabPanel("Gráfico 3: Tiempo de actividad de clientes",
plotOutput("grafico3b"),
plotOutput("grafico3h")
),
tabPanel("Gráfico 4: Intervalo promedio entre compras",
plotOutput("grafico4b"),
plotOutput("grafico4h")
),
tabPanel("Gráfico 5: Compras por día de la semana",
plotOutput("grafico5")
)
)
)
#Server
server<- function(input, output, session) {
#Gráfico 1
output$grafico1 <- renderPlot({
tickets_enc %>%
group_by(num_ticket, id_cliente_enc) %>%
summarise(ArticulosPorCompra = n(), .groups = "drop") %>%
ggplot(aes(x = ArticulosPorCompra)) +
geom_histogram(color = "lightblue4", fill = "lightblue", binwidth = 1) +
labs(title = "Cantidad de artículos que se llevan por compra",
y = "Cantidad de tickets",
x = "Artículos por ticket") +
theme_minimal()
})
#Gráfico 2
output$grafico2 <- renderPlot({
top_articulos <- tickets_enc %>%
group_by(cod_est) %>%
summarise(Cantidad = n(), .groups = "drop") %>%
arrange(desc(Cantidad)) %>%
head(10) %>%
left_join(maestroestr, by = "cod_est")
ggplot(top_articulos, aes(x = reorder(descripcion, Cantidad), y = Cantidad)) +
geom_col(fill = "lightblue", color = "lightblue4") +
labs(title = "Top 10 artículos más comprados",
x = "Artículo",
y = "Cantidad de veces comprado") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
#Gráfico 3b y 3h
output$grafico3b <- renderPlot({
duraciones <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
primera_compra = min(dia),
ultima_compra = max(dia),
duracion_dias = as.numeric(ultima_compra - primera_compra),
.groups = "drop"
)
ggplot(duraciones, aes(y = duracion_dias)) +
geom_boxplot(fill = "lightblue", color = "lightblue4") +
labs(title = "Distribución del tiempo de actividad de los clientes",
y = "Duración entre primera y última compra (días)") +
theme_minimal()
})
output$grafico3h <- renderPlot({
duraciones <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
primera_compra = min(dia),
ultima_compra = max(dia),
duracion_dias = as.numeric(ultima_compra - primera_compra),
.groups = "drop"
)
ggplot(duraciones, aes(x = duracion_dias)) +
geom_histogram(binwidth = 30, fill = "lightblue", color = "lightblue4") +
labs(title = "Tiempo de actividad de los clientes",
x = "Duración entre primera y última compra (días)",
y = "Número de clientes") +
theme_minimal()
})
#Gráfico 4b y 4h
output$grafico4b <- renderPlot({
intervalos <- tickets_enc %>%
arrange(id_cliente_enc, dia) %>%
group_by(id_cliente_enc) %>%
mutate(intervalo = as.numeric(difftime(dia, lag(dia), units = "days"))) %>%
filter(!is.na(intervalo)) %>%
summarise(media_intervalo = mean(intervalo), .groups = "drop")
ggplot(intervalos, aes(y = media_intervalo)) +
geom_boxplot(color = "lightblue4", fill = "lightblue") +
labs(title = "Distribución de la frecuencia de compra de los clientes",
y = "Días promedio entre compras") +
coord_cartesian(ylim = c(0, 10)) +
theme_minimal()
})
output$grafico4h <- renderPlot({
intervalos <- tickets_enc %>%
arrange(id_cliente_enc, dia) %>%
group_by(id_cliente_enc) %>%
mutate(intervalo = as.numeric(difftime(dia, lag(dia), units = "days"))) %>%
filter(!is.na(intervalo)) %>%
summarise(media_intervalo = mean(intervalo), .groups = "drop")
ggplot(intervalos, aes(x = media_intervalo)) +
geom_histogram(binwidth = 1, color = "lightblue4", fill = "lightblue") +
labs(title = "Media de días entre compras por cliente",
x = "Media de días entre compras",
y = "Cantidad de clientes") +
coord_cartesian(xlim = c(0, 8)) +
theme_minimal()
})
#Gráfico 5
output$grafico5 <- renderPlot({
tickets_enc %>%
mutate(DiaSemana = wday(dia)) %>%
group_by(DiaSemana) %>%
summarise(CantidadProductos = n(), .groups = "drop") %>%
mutate(DiaSemana = factor(DiaSemana, levels = 1:7, labels = c("Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"))) %>%
ggplot(aes(x = CantidadProductos, y = reorder(DiaSemana, CantidadProductos))) +
geom_col(fill = "lightblue", color = "lightblue4") +
labs(title = "Cantidad de productos comprados por día de la semana",
x = "Cantidad de Productos",
y = "Día de la Semana") +
theme_minimal()
})
}
#Ejecutar app
shinyApp(ui = ui, server = server)
library(lubridate)
library(dplyr)
library(naniar)
library(tidyr)
library(ggplot2)
library(corrplot)
library(cluster)
library(dendextend)
# Cargar los datos
maestrostr <- readRDS("Datos/Originales/maestroestr.RDS")
library(lubridate)
library(dplyr)
library(naniar)
library(tidyr)
library(ggplot2)
library(corrplot)
library(cluster)
library(dendextend)
# Cargar los datos
maestrostr <- readRDS("Datos//maestroestr.RDS")
objetivos <- readRDS("Datos//objetivos.RDS")
tickets_enc <- readRDS("Datos//tickets_enc.RDS")
# Inspeccionar los datos
str(tickets_enc)
tickets_enc$num_ticket <- as.character(tickets_enc$num_ticket)
tickets_enc$dia <- ymd(tickets_enc$dia)
str(tickets_enc)
summary(tickets_enc)
vis_miss(tickets_enc, warn_large_data = FALSE) # No se encuentran NA's
# Tratamiento de tickets duplicados
df <- tickets_enc %>%
group_by(dia, num_ticket, id_cliente_enc) %>%
summarise(productos = list(table(cod_est)), .groups = "drop")
rm(df)
tickets_enc <- tickets_enc %>%
mutate(num_ticket = paste(num_ticket, id_cliente_enc))
# Comprobación de tickets duplicados
df_ticket <- tickets_enc %>%
group_by(num_ticket) %>%
summarise(NumClientesUnicos = n_distinct(id_cliente_enc))
max(df_ticket$NumClientesUnicos)  # Es 1 por lo que no se repiten
rm(df_ticket)
# Identificación de día de la semana de cada compra
tickets_enc <- tickets_enc %>%
mutate(DiaSemana = wday(dia, week_start=1))
# Caracterización de los clientes - Columnas para clustering
datos_clientes <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
total_productos = n(),  # Número total de compras (filas en la base de datos)
productos_distintos = n_distinct(cod_est),  # Número de productos únicos comprados
dias_activos = as.numeric(max(dia) - min(dia)),
compras_por_semana = ifelse(dias_activos > 0, n() / (dias_activos / 7), n()), # Evitar división por 0
compras_entre_semana = sum(DiaSemana %in% 1:5),  # Compras de lunes a viernes
compras_fin_de_semana = sum(DiaSemana %in% 6:7)   # Compras en sábado o domingo
) %>%
ungroup()
saveRDS(datos_clientes, "Datos/datos_para_clustering.RDS")
# Cargar datos preparados para clustering
datos_clientes <- readRDS("Datos/datos_para_clustering.RDS")
str(datos_clientes)
summary(datos_clientes)
# Visualización de outliers con boxplot
datos_largos <- datos_clientes %>%
pivot_longer(cols = -id_cliente_enc, names_to = "variable", values_to = "valor")
ggplot(datos_largos, aes(x = variable, y = valor)) +
geom_boxplot(outlier.colour = "red", fill = "lightblue") +
theme_minimal() +
labs(title = "Detección de Outliers", x = "Variable", y = "Valor") +
coord_flip()
# Detección de outliers usando el criterio IQR
outliers_iqr <- function(x) {
q1 <- quantile(x, 0.25, na.rm = TRUE)
q3 <- quantile(x, 0.75, na.rm = TRUE)
iqr <- q3 - q1
which(x < (q1 - 1.5 * iqr) | x > (q3 + 1.5 * iqr))
}
# Detectar outliers por cada variable numérica
outlier_indices <- lapply(datos_clientes[,-1], outliers_iqr)
names(outlier_indices) <- names(datos_clientes[,-1])
# Obtener índices únicos de filas con al menos un outlier
filas_outliers <- unique(unlist(outlier_indices))
# Eliminar las filas con outliers
datos_sin_outliers <- datos_clientes[-filas_outliers, ]
# Verificación
cat("Filas originales:", nrow(datos_clientes), "\n")
cat("Filas con outliers eliminadas:", length(filas_outliers), "\n")
cat("Filas finales:", nrow(datos_sin_outliers), "\n")
# 1. Escalado de las variables para el clustering
datos_cluster <- datos_sin_outliers %>%
select(-id_cliente_enc)
datos_scaled <- scale(datos_cluster)
# 2. Método del codo para K-means
set.seed(123)
wss <- numeric(15)
for (i in 1:15) {
kmeans_result <- kmeans(datos_scaled, centers = i, nstart = 25)
wss[i] <- kmeans_result$tot.withinss
}
# Gráfico del codo
ggplot(data.frame(k = 1:15, wss = wss), aes(x = k, y = wss)) +
geom_line() +
geom_point() +
labs(title = "Método del Codo", x = "Número de Clusters", y = "Suma de Cuadrados dentro de los Clusters")
# Elegimos el número óptimo de clusters (ejemplo: k = 3)
kmeans_result <- kmeans(datos_scaled, centers = 3, nstart = 25)
# 3. Clustering Jerárquico
dist_matrix <- dist(datos_scaled)
# Aplico el clustering jerárquico (método de aglomeración completo)
hclust_result <- hclust(dist_matrix, method = "complete")
# Visualizo el dendrograma
plot(hclust_result, main = "Dendrograma de Clustering Jerárquico", xlab = "", sub = "")
# Cortamos el dendrograma en 3 clusters
hclust_clusters <- cutree(hclust_result, k = 3)
# 4. Comparación de K-means y Clustering Jerárquico
datos_sin_outliers$kmeans_cluster <- as.factor(kmeans_result$cluster)
datos_sin_outliers$hclust_cluster <- as.factor(hclust_clusters)
# 5. Comparación Intra-cluster e Inter-cluster
intra_kmeans <- sum(kmeans_result$withinss)
# Jerárquico: Variabilidad dentro de los clusters
intra_hclust <- sum(sapply(1:3, function(k) {
cluster_data <- datos_scaled[hclust_clusters == k, ]
mean(dist(cluster_data))
}))
# Calculamos la dispersión inter-cluster para ambos métodos
centroids <- kmeans_result$centers
inter_kmeans <- sum(sapply(1:3, function(k) {
sum(dist(rbind(centroids[k, ], datos_scaled[kmeans_result$cluster == k, ])))
}))
# Jerárquico: Variabilidad entre los clusters
centroids_hclust <- sapply(1:3, function(k) colMeans(datos_scaled[hclust_clusters == k, ]))
inter_hclust <- sum(sapply(1:3, function(k) {
sum(dist(rbind(centroids_hclust[k, ], datos_scaled[hclust_clusters == k, ])))
}))
# Mostrar resultados
cat("Intra-cluster K-means:", intra_kmeans, "\n")
cat("Intra-cluster Jerárquico:", intra_hclust, "\n")
cat("Inter-cluster K-means:", inter_kmeans, "\n")
cat("Inter-cluster Jerárquico:", inter_hclust, "\n")
# 6. Visualización de los resultados de los clusters
pca_result <- prcomp(datos_scaled)
datos_sin_outliers$pca1 <- pca_result$x[, 1]
datos_sin_outliers$pca2 <- pca_result$x[, 2]
ggplot(datos_sin_outliers, aes(x = pca1, y = pca2, color = kmeans_cluster)) +
geom_point(alpha = 0.7) +
theme_minimal() +
labs(title = "Clusters K-means", x = "Componente Principal 1", y = "Componente Principal 2") +
scale_color_manual(values = c("red", "blue", "green"))
ggplot(datos_sin_outliers, aes(x = pca1, y = pca2, color = hclust_cluster)) +
geom_point(alpha = 0.7) +
theme_minimal() +
labs(title = "Clusters Jerárquico", x = "Componente Principal 1", y = "Componente Principal 2") +
scale_color_manual(values = c("purple", "orange", "yellow"))
library(dplyr)
# 1. Cargar la matriz reducida y los clusters
matriz_df <- readRDS("Datos/matriz.RDS")
datos_clusters <- readRDS("Datos/datos_para_clustering.RDS")  # Este contiene 'id_cliente_enc' y 'kmeans_cluster'
# Asegurarse de que ambos tengan el ID en el mismo formato
matriz_df$id_cliente_enc <- rownames(matriz_df)
# Unir la matriz con la información de cluster
matriz_con_cluster <- matriz_df %>%
inner_join(datos_clusters %>% select(id_cliente_enc, kmeans_cluster), by = "id_cliente_enc")
datos_clusters
View(datos_cluster)
View(datos_clusters)
# Librerías necesarias
library(lubridate)
library(dplyr)
library(naniar)
library(tidyr)
library(ggplot2)
library(cluster)
# Cargar los datos
maestrostr <- readRDS("Datos//maestroestr.RDS")
objetivos <- readRDS("Datos//objetivos.RDS")
tickets_enc <- readRDS("Datos//tickets_enc.RDS")
# Formateo inicial
tickets_enc$num_ticket <- as.character(tickets_enc$num_ticket)
tickets_enc$dia <- ymd(tickets_enc$dia)
# Verificar NAs
vis_miss(tickets_enc, warn_large_data = FALSE)  # No hay NAs
# Eliminar tickets duplicados (comprobado que no se repiten)
tickets_enc <- tickets_enc %>%
mutate(num_ticket = paste(num_ticket, id_cliente_enc))
# Agregar día de la semana
tickets_enc <- tickets_enc %>%
mutate(DiaSemana = wday(dia, week_start = 1))
# Características de clientes para clustering
datos_clientes <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
total_productos = n(),
productos_distintos = n_distinct(cod_est),
dias_activos = as.numeric(max(dia) - min(dia)),
compras_por_semana = ifelse(dias_activos > 0, n() / (dias_activos / 7), n()),
compras_entre_semana = sum(DiaSemana %in% 1:5),
compras_fin_de_semana = sum(DiaSemana %in% 6:7)
) %>%
ungroup()
saveRDS(datos_clientes, "Datos/datos_para_clustering.RDS")
# Eliminar outliers usando IQR
outliers_iqr <- function(x) {
q1 <- quantile(x, 0.25, na.rm = TRUE)
q3 <- quantile(x, 0.75, na.rm = TRUE)
iqr <- q3 - q1
which(x < (q1 - 1.5 * iqr) | x > (q3 + 1.5 * iqr))
}
outlier_indices <- lapply(datos_clientes[,-1], outliers_iqr)
filas_outliers <- unique(unlist(outlier_indices))
datos_sin_outliers <- datos_clientes[-filas_outliers, ]
# Escalado de variables
datos_cluster <- datos_sin_outliers %>% select(-id_cliente_enc)
datos_scaled <- scale(datos_cluster)
# Método del codo para K-means
set.seed(123)
wss <- numeric(15)
for (i in 1:15) {
wss[i] <- kmeans(datos_scaled, centers = i, nstart = 25)$tot.withinss
}
# Graficar codo
ggplot(data.frame(k = 1:15, wss = wss), aes(x = k, y = wss)) +
geom_line() +
geom_point() +
labs(title = "Método del Codo", x = "Número de Clusters", y = "Suma de Cuadrados Intra-cluster")
# Ejecutar K-means con k = 3 (puedes ajustar este valor según el gráfico del codo)
set.seed(123)
kmeans_result <- kmeans(datos_scaled, centers = 3, nstart = 25)
datos_sin_outliers$kmeans_cluster <- as.factor(kmeans_result$cluster)
# Visualización en 2D con PCA
pca_result <- prcomp(datos_scaled)
datos_sin_outliers$pca1 <- pca_result$x[,1]
datos_sin_outliers$pca2 <- pca_result$x[,2]
ggplot(datos_sin_outliers, aes(x = pca1, y = pca2, color = kmeans_cluster)) +
geom_point(alpha = 0.7) +
theme_minimal() +
labs(title = "Clusters K-means", x = "Componente Principal 1", y = "Componente Principal 2") +
scale_color_manual(values = c("red", "blue", "green"))
# Guardar clientes con cluster asignado
clientes_clusterizados <- datos_sin_outliers %>%
select(id_cliente_enc, kmeans_cluster)
saveRDS(clientes_clusterizados, "Datos/clientes_clusterizados.RDS")
# Aplicar clusters a la matriz cliente-producto
matriz_df <- readRDS("Datos/matriz.RDS")
matriz_df$id_cliente_enc <- rownames(matriz_df)
matriz_con_cluster <- matriz_df %>%
inner_join(clientes_clusterizados, by = "id_cliente_enc")
producto_cols <- setdiff(names(matriz_con_cluster), c("id_cliente_enc", "kmeans_cluster"))
# Crear matriz por clúster
matrices_por_cluster <- matriz_con_cluster %>%
group_split(kmeans_cluster) %>%
setNames(paste0("Cluster_", unique(matriz_con_cluster$kmeans_cluster))) %>%
lapply(function(df) {
mat <- df[, producto_cols]
rownames(mat) <- df$id_cliente_enc
return(as.matrix(mat))
})
# Guardar matrices por cluster
for (i in names(matrices_por_cluster)) {
saveRDS(matrices_por_cluster[[i]], paste0("Datos/matriz_", i, ".RDS"))
}
# Verificar dimensiones
lapply(matrices_por_cluster, dim)
